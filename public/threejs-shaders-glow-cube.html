<!DOCTYPE html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>WebGL Test</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" href="css/bootstrap-slate.min.css">
        <link rel="stylesheet" type="text/css" href="css/galactron.css">
        <style type="text/css">
        #canvas {
            width: 640px;
            height: 480px;
            border: 1px solid black;
            background-color: #600;
            margin-left: auto;
            margin-right: auto;
            display: block;
        }
        </style>
        <script type="text/javascript" src="js/dat.gui.min.js"></script>
        <script type="text/javascript" src="js/jquery-2.1.1.min.js"></script>
        <script type="text/javascript" src="js/three.min.js"></script>
        <script type="text/javascript" src="js/threejs-shaders-glow-cube.js"></script>
    </head>
    <body>
    <h1>WebGL: Custom Shader - Edge Glow</h1>

    <canvas id="canvas" width="640" height="480">
        Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
    </canvas>

    <p>No textures are used. This shader currently only works well for cubes, since it uses the Texture UV coordinates to determine
    fragment distance from the edge, and based on the distance, apply the alpha fallout to the glow gradient. A future version should use the barycentric coordinates of rendered triangles in order to work for all edges.</p>

    <script type="x-shader/x-vertex" id="vertexShader">
        varying vec2 vUv;

        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        precision highp float;
        varying vec2 vUv;
        uniform float edgeWidth;
        float opacity;
        
        /**
         * We use the UV coordinates of the fragments in order to calculate the distance
         * to an edge. If the distance is under "edgeWidth", we color the fragment, otherwise
         * we make it transparent. This gives the object a wireframed look with configurable
         * line width, but probably only works for quads.
         */
        void main(void) {
            if( vUv[0]<(0.0 + edgeWidth) && (vUv[0] < vUv[1]) && ( vUv[0] < (1.0 - vUv[1]))){
                opacity = 1.0 - (vUv[0] / edgeWidth);
                gl_FragColor = vec4(0.0, 1.0, 0.0, opacity);

            } else if(vUv[0]>(1.0 - edgeWidth) && (vUv[0] > vUv[1]) && ( vUv[0] > (1.0 - vUv[1]))) {
                opacity = 1.0 - ((1.0 - vUv[0]) / edgeWidth);
                gl_FragColor = vec4(0.0, 1.0, 0.0, opacity);

            } else if(vUv[1]<(0.0 + edgeWidth) && (vUv[1] < vUv[0]) && ( vUv[1] < (1.0 - vUv[0]))) {
                opacity = 1.0 - (vUv[1] / edgeWidth);
                gl_FragColor = vec4(0.0, 1.0, 0.0, opacity);

            } else if(vUv[1]>(1.0 - edgeWidth)) {
                opacity = 1.0 - ((1.0 - vUv[1]) / edgeWidth);
                gl_FragColor = vec4(0.0, 1.0, 0.0, opacity);

            } else {
                gl_FragColor = vec4(1.0, 1.0, 1.0, 0.0);
            }
        }
    </script>

    </body>
</html>
